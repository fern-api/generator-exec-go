// Code generated by Fern. DO NOT EDIT.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/fern-api/generator-exec-go/internal"
	big "math/big"
)

var (
	cratesCoordinateFieldName    = big.NewInt(1 << 0)
	cratesCoordinateFieldVersion = big.NewInt(1 << 1)
)

type CratesCoordinate struct {
	Name    string `json:"name" url:"name"`
	Version string `json:"version" url:"version"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CratesCoordinate) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CratesCoordinate) GetVersion() string {
	if c == nil {
		return ""
	}
	return c.Version
}

func (c *CratesCoordinate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CratesCoordinate) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CratesCoordinate) SetName(name string) {
	c.Name = name
	c.require(cratesCoordinateFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CratesCoordinate) SetVersion(version string) {
	c.Version = version
	c.require(cratesCoordinateFieldVersion)
}

func (c *CratesCoordinate) UnmarshalJSON(data []byte) error {
	type unmarshaler CratesCoordinate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CratesCoordinate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CratesCoordinate) MarshalJSON() ([]byte, error) {
	type embed CratesCoordinate
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CratesCoordinate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	errorExitStatusUpdateFieldMessage = big.NewInt(1 << 0)
)

type ErrorExitStatusUpdate struct {
	Message string `json:"message" url:"message"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorExitStatusUpdate) GetMessage() string {
	if e == nil {
		return ""
	}
	return e.Message
}

func (e *ErrorExitStatusUpdate) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorExitStatusUpdate) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorExitStatusUpdate) SetMessage(message string) {
	e.Message = message
	e.require(errorExitStatusUpdateFieldMessage)
}

func (e *ErrorExitStatusUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorExitStatusUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorExitStatusUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorExitStatusUpdate) MarshalJSON() ([]byte, error) {
	type embed ErrorExitStatusUpdate
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ErrorExitStatusUpdate) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExitStatusUpdate struct {
	Type       string
	Successful *SuccessfulStatusUpdate
	Error      *ErrorExitStatusUpdate
}

func (e *ExitStatusUpdate) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *ExitStatusUpdate) GetSuccessful() *SuccessfulStatusUpdate {
	if e == nil {
		return nil
	}
	return e.Successful
}

func (e *ExitStatusUpdate) GetError() *ErrorExitStatusUpdate {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExitStatusUpdate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", e)
	}
	switch unmarshaler.Type {
	case "successful":
		value := new(SuccessfulStatusUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Successful = value
	case "error":
		value := new(ErrorExitStatusUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExitStatusUpdate) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Successful != nil {
		return internal.MarshalJSONWithExtraProperty(e.Successful, "_type", "successful")
	}
	if e.Error != nil {
		return internal.MarshalJSONWithExtraProperty(e.Error, "_type", "error")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExitStatusUpdateVisitor interface {
	VisitSuccessful(*SuccessfulStatusUpdate) error
	VisitError(*ErrorExitStatusUpdate) error
}

func (e *ExitStatusUpdate) Accept(visitor ExitStatusUpdateVisitor) error {
	if e.Successful != nil {
		return visitor.VisitSuccessful(e.Successful)
	}
	if e.Error != nil {
		return visitor.VisitError(e.Error)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *ExitStatusUpdate) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Successful != nil {
		fields = append(fields, "successful")
	}
	if e.Error != nil {
		fields = append(fields, "error")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

type GeneratorUpdate struct {
	Type             string
	Init             *InitUpdate
	InitV2           *InitUpdateV2
	Log              *LogUpdate
	Publishing       *PackageCoordinate
	Published        *PackageCoordinate
	ExitStatusUpdate *ExitStatusUpdate
}

func (g *GeneratorUpdate) GetType() string {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GeneratorUpdate) GetInit() *InitUpdate {
	if g == nil {
		return nil
	}
	return g.Init
}

func (g *GeneratorUpdate) GetInitV2() *InitUpdateV2 {
	if g == nil {
		return nil
	}
	return g.InitV2
}

func (g *GeneratorUpdate) GetLog() *LogUpdate {
	if g == nil {
		return nil
	}
	return g.Log
}

func (g *GeneratorUpdate) GetPublishing() *PackageCoordinate {
	if g == nil {
		return nil
	}
	return g.Publishing
}

func (g *GeneratorUpdate) GetPublished() *PackageCoordinate {
	if g == nil {
		return nil
	}
	return g.Published
}

func (g *GeneratorUpdate) GetExitStatusUpdate() *ExitStatusUpdate {
	if g == nil {
		return nil
	}
	return g.ExitStatusUpdate
}

func (g *GeneratorUpdate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", g)
	}
	switch unmarshaler.Type {
	case "init":
		value := new(InitUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Init = value
	case "initV2":
		value := new(InitUpdateV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.InitV2 = value
	case "log":
		value := new(LogUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Log = value
	case "publishing":
		var valueUnmarshaler struct {
			Publishing *PackageCoordinate `json:"publishing"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.Publishing = valueUnmarshaler.Publishing
	case "published":
		var valueUnmarshaler struct {
			Published *PackageCoordinate `json:"published"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.Published = valueUnmarshaler.Published
	case "exitStatusUpdate":
		var valueUnmarshaler struct {
			ExitStatusUpdate *ExitStatusUpdate `json:"exitStatusUpdate"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.ExitStatusUpdate = valueUnmarshaler.ExitStatusUpdate
	}
	return nil
}

func (g GeneratorUpdate) MarshalJSON() ([]byte, error) {
	if err := g.validate(); err != nil {
		return nil, err
	}
	if g.Init != nil {
		return internal.MarshalJSONWithExtraProperty(g.Init, "_type", "init")
	}
	if g.InitV2 != nil {
		return internal.MarshalJSONWithExtraProperty(g.InitV2, "_type", "initV2")
	}
	if g.Log != nil {
		return internal.MarshalJSONWithExtraProperty(g.Log, "_type", "log")
	}
	if g.Publishing != nil {
		var marshaler = struct {
			Type       string             `json:"_type"`
			Publishing *PackageCoordinate `json:"publishing"`
		}{
			Type:       "publishing",
			Publishing: g.Publishing,
		}
		return json.Marshal(marshaler)
	}
	if g.Published != nil {
		var marshaler = struct {
			Type      string             `json:"_type"`
			Published *PackageCoordinate `json:"published"`
		}{
			Type:      "published",
			Published: g.Published,
		}
		return json.Marshal(marshaler)
	}
	if g.ExitStatusUpdate != nil {
		var marshaler = struct {
			Type             string            `json:"_type"`
			ExitStatusUpdate *ExitStatusUpdate `json:"exitStatusUpdate"`
		}{
			Type:             "exitStatusUpdate",
			ExitStatusUpdate: g.ExitStatusUpdate,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GeneratorUpdateVisitor interface {
	VisitInit(*InitUpdate) error
	VisitInitV2(*InitUpdateV2) error
	VisitLog(*LogUpdate) error
	VisitPublishing(*PackageCoordinate) error
	VisitPublished(*PackageCoordinate) error
	VisitExitStatusUpdate(*ExitStatusUpdate) error
}

func (g *GeneratorUpdate) Accept(visitor GeneratorUpdateVisitor) error {
	if g.Init != nil {
		return visitor.VisitInit(g.Init)
	}
	if g.InitV2 != nil {
		return visitor.VisitInitV2(g.InitV2)
	}
	if g.Log != nil {
		return visitor.VisitLog(g.Log)
	}
	if g.Publishing != nil {
		return visitor.VisitPublishing(g.Publishing)
	}
	if g.Published != nil {
		return visitor.VisitPublished(g.Published)
	}
	if g.ExitStatusUpdate != nil {
		return visitor.VisitExitStatusUpdate(g.ExitStatusUpdate)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

func (g *GeneratorUpdate) validate() error {
	if g == nil {
		return fmt.Errorf("type %T is nil", g)
	}
	var fields []string
	if g.Init != nil {
		fields = append(fields, "init")
	}
	if g.InitV2 != nil {
		fields = append(fields, "initV2")
	}
	if g.Log != nil {
		fields = append(fields, "log")
	}
	if g.Publishing != nil {
		fields = append(fields, "publishing")
	}
	if g.Published != nil {
		fields = append(fields, "published")
	}
	if g.ExitStatusUpdate != nil {
		fields = append(fields, "exitStatusUpdate")
	}
	if len(fields) == 0 {
		if g.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", g, g.Type)
		}
		return fmt.Errorf("type %T is empty", g)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", g, fields)
	}
	if g.Type != "" {
		field := fields[0]
		if g.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				g,
				g.Type,
				g,
			)
		}
	}
	return nil
}

var (
	initUpdateFieldPackagesToPublish = big.NewInt(1 << 0)
)

type InitUpdate struct {
	PackagesToPublish []*PackageCoordinate `json:"packagesToPublish" url:"packagesToPublish"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InitUpdate) GetPackagesToPublish() []*PackageCoordinate {
	if i == nil {
		return nil
	}
	return i.PackagesToPublish
}

func (i *InitUpdate) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InitUpdate) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetPackagesToPublish sets the PackagesToPublish field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InitUpdate) SetPackagesToPublish(packagesToPublish []*PackageCoordinate) {
	i.PackagesToPublish = packagesToPublish
	i.require(initUpdateFieldPackagesToPublish)
}

func (i *InitUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler InitUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InitUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InitUpdate) MarshalJSON() ([]byte, error) {
	type embed InitUpdate
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InitUpdate) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	initUpdateV2FieldPublishingToRegistry = big.NewInt(1 << 0)
)

type InitUpdateV2 struct {
	PublishingToRegistry *RegistryType `json:"publishingToRegistry,omitempty" url:"publishingToRegistry,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InitUpdateV2) GetPublishingToRegistry() *RegistryType {
	if i == nil {
		return nil
	}
	return i.PublishingToRegistry
}

func (i *InitUpdateV2) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InitUpdateV2) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetPublishingToRegistry sets the PublishingToRegistry field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InitUpdateV2) SetPublishingToRegistry(publishingToRegistry *RegistryType) {
	i.PublishingToRegistry = publishingToRegistry
	i.require(initUpdateV2FieldPublishingToRegistry)
}

func (i *InitUpdateV2) UnmarshalJSON(data []byte) error {
	type unmarshaler InitUpdateV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InitUpdateV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InitUpdateV2) MarshalJSON() ([]byte, error) {
	type embed InitUpdateV2
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InitUpdateV2) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LogLevel string

const (
	LogLevelDebug LogLevel = "DEBUG"
	LogLevelInfo  LogLevel = "INFO"
	LogLevelWarn  LogLevel = "WARN"
	LogLevelError LogLevel = "ERROR"
)

func NewLogLevelFromString(s string) (LogLevel, error) {
	switch s {
	case "DEBUG":
		return LogLevelDebug, nil
	case "INFO":
		return LogLevelInfo, nil
	case "WARN":
		return LogLevelWarn, nil
	case "ERROR":
		return LogLevelError, nil
	}
	var t LogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LogLevel) Ptr() *LogLevel {
	return &l
}

var (
	logUpdateFieldLevel   = big.NewInt(1 << 0)
	logUpdateFieldMessage = big.NewInt(1 << 1)
)

type LogUpdate struct {
	Level   LogLevel `json:"level" url:"level"`
	Message string   `json:"message" url:"message"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LogUpdate) GetLevel() LogLevel {
	if l == nil {
		return ""
	}
	return l.Level
}

func (l *LogUpdate) GetMessage() string {
	if l == nil {
		return ""
	}
	return l.Message
}

func (l *LogUpdate) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogUpdate) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLevel sets the Level field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LogUpdate) SetLevel(level LogLevel) {
	l.Level = level
	l.require(logUpdateFieldLevel)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LogUpdate) SetMessage(message string) {
	l.Message = message
	l.require(logUpdateFieldMessage)
}

func (l *LogUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler LogUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogUpdate) MarshalJSON() ([]byte, error) {
	type embed LogUpdate
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LogUpdate) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	mavenCoordinateFieldGroup    = big.NewInt(1 << 0)
	mavenCoordinateFieldArtifact = big.NewInt(1 << 1)
	mavenCoordinateFieldVersion  = big.NewInt(1 << 2)
)

type MavenCoordinate struct {
	Group    string `json:"group" url:"group"`
	Artifact string `json:"artifact" url:"artifact"`
	Version  string `json:"version" url:"version"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MavenCoordinate) GetGroup() string {
	if m == nil {
		return ""
	}
	return m.Group
}

func (m *MavenCoordinate) GetArtifact() string {
	if m == nil {
		return ""
	}
	return m.Artifact
}

func (m *MavenCoordinate) GetVersion() string {
	if m == nil {
		return ""
	}
	return m.Version
}

func (m *MavenCoordinate) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCoordinate) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetGroup sets the Group field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCoordinate) SetGroup(group string) {
	m.Group = group
	m.require(mavenCoordinateFieldGroup)
}

// SetArtifact sets the Artifact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCoordinate) SetArtifact(artifact string) {
	m.Artifact = artifact
	m.require(mavenCoordinateFieldArtifact)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MavenCoordinate) SetVersion(version string) {
	m.Version = version
	m.require(mavenCoordinateFieldVersion)
}

func (m *MavenCoordinate) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCoordinate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCoordinate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MavenCoordinate) MarshalJSON() ([]byte, error) {
	type embed MavenCoordinate
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MavenCoordinate) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	npmCoordinateFieldName    = big.NewInt(1 << 0)
	npmCoordinateFieldVersion = big.NewInt(1 << 1)
)

type NpmCoordinate struct {
	Name    string `json:"name" url:"name"`
	Version string `json:"version" url:"version"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NpmCoordinate) GetName() string {
	if n == nil {
		return ""
	}
	return n.Name
}

func (n *NpmCoordinate) GetVersion() string {
	if n == nil {
		return ""
	}
	return n.Version
}

func (n *NpmCoordinate) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmCoordinate) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmCoordinate) SetName(name string) {
	n.Name = name
	n.require(npmCoordinateFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NpmCoordinate) SetVersion(version string) {
	n.Version = version
	n.require(npmCoordinateFieldVersion)
}

func (n *NpmCoordinate) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmCoordinate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmCoordinate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NpmCoordinate) MarshalJSON() ([]byte, error) {
	type embed NpmCoordinate
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NpmCoordinate) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PackageCoordinate struct {
	Type   string
	Npm    *NpmCoordinate
	Maven  *MavenCoordinate
	Crates *CratesCoordinate
}

func (p *PackageCoordinate) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PackageCoordinate) GetNpm() *NpmCoordinate {
	if p == nil {
		return nil
	}
	return p.Npm
}

func (p *PackageCoordinate) GetMaven() *MavenCoordinate {
	if p == nil {
		return nil
	}
	return p.Maven
}

func (p *PackageCoordinate) GetCrates() *CratesCoordinate {
	if p == nil {
		return nil
	}
	return p.Crates
}

func (p *PackageCoordinate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", p)
	}
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "maven":
		value := new(MavenCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "crates":
		value := new(CratesCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Crates = value
	}
	return nil
}

func (p PackageCoordinate) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(p.Npm, "_type", "npm")
	}
	if p.Maven != nil {
		return internal.MarshalJSONWithExtraProperty(p.Maven, "_type", "maven")
	}
	if p.Crates != nil {
		return internal.MarshalJSONWithExtraProperty(p.Crates, "_type", "crates")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PackageCoordinateVisitor interface {
	VisitNpm(*NpmCoordinate) error
	VisitMaven(*MavenCoordinate) error
	VisitCrates(*CratesCoordinate) error
}

func (p *PackageCoordinate) Accept(visitor PackageCoordinateVisitor) error {
	if p.Npm != nil {
		return visitor.VisitNpm(p.Npm)
	}
	if p.Maven != nil {
		return visitor.VisitMaven(p.Maven)
	}
	if p.Crates != nil {
		return visitor.VisitCrates(p.Crates)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PackageCoordinate) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Npm != nil {
		fields = append(fields, "npm")
	}
	if p.Maven != nil {
		fields = append(fields, "maven")
	}
	if p.Crates != nil {
		fields = append(fields, "crates")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type RegistryType string

const (
	RegistryTypeNpm      RegistryType = "NPM"
	RegistryTypeMaven    RegistryType = "MAVEN"
	RegistryTypePypi     RegistryType = "PYPI"
	RegistryTypeRubygems RegistryType = "RUBYGEMS"
	RegistryTypeNuget    RegistryType = "NUGET"
	RegistryTypeCrates   RegistryType = "CRATES"
)

func NewRegistryTypeFromString(s string) (RegistryType, error) {
	switch s {
	case "NPM":
		return RegistryTypeNpm, nil
	case "MAVEN":
		return RegistryTypeMaven, nil
	case "PYPI":
		return RegistryTypePypi, nil
	case "RUBYGEMS":
		return RegistryTypeRubygems, nil
	case "NUGET":
		return RegistryTypeNuget, nil
	case "CRATES":
		return RegistryTypeCrates, nil
	}
	var t RegistryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegistryType) Ptr() *RegistryType {
	return &r
}

var (
	successfulStatusUpdateFieldZipFilename = big.NewInt(1 << 0)
)

type SuccessfulStatusUpdate struct {
	ZipFilename *string `json:"zipFilename,omitempty" url:"zipFilename,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessfulStatusUpdate) GetZipFilename() *string {
	if s == nil {
		return nil
	}
	return s.ZipFilename
}

func (s *SuccessfulStatusUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessfulStatusUpdate) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetZipFilename sets the ZipFilename field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SuccessfulStatusUpdate) SetZipFilename(zipFilename *string) {
	s.ZipFilename = zipFilename
	s.require(successfulStatusUpdateFieldZipFilename)
}

func (s *SuccessfulStatusUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessfulStatusUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessfulStatusUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessfulStatusUpdate) MarshalJSON() ([]byte, error) {
	type embed SuccessfulStatusUpdate
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SuccessfulStatusUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TaskId = string
