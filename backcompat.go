// Code generated by Fern. DO NOT EDIT.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/fern-api/generator-exec-go/internal"
	big "math/big"
)

// For the TS generators that use strict parsing.
var (
	backwardsCompatGeneratorPublishConfigFieldRegistries    = big.NewInt(1 << 0)
	backwardsCompatGeneratorPublishConfigFieldRegistriesV2  = big.NewInt(1 << 1)
	backwardsCompatGeneratorPublishConfigFieldPublishTarget = big.NewInt(1 << 2)
	backwardsCompatGeneratorPublishConfigFieldVersion       = big.NewInt(1 << 3)
)

type BackwardsCompatGeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries" url:"registries"`
	// Deprecated, use publishTargets instead.
	RegistriesV2 *BackwardsCompatibleRegistriesConfigV2 `json:"registriesV2" url:"registriesV2"`
	// Must always be TS for TypeScript
	PublishTarget *BackwardsCompatiblePublishTarget `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`
	Version       string                            `json:"version" url:"version"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BackwardsCompatGeneratorPublishConfig) GetRegistries() *GeneratorRegistriesConfig {
	if b == nil {
		return nil
	}
	return b.Registries
}

func (b *BackwardsCompatGeneratorPublishConfig) GetRegistriesV2() *BackwardsCompatibleRegistriesConfigV2 {
	if b == nil {
		return nil
	}
	return b.RegistriesV2
}

func (b *BackwardsCompatGeneratorPublishConfig) GetPublishTarget() *BackwardsCompatiblePublishTarget {
	if b == nil {
		return nil
	}
	return b.PublishTarget
}

func (b *BackwardsCompatGeneratorPublishConfig) GetVersion() string {
	if b == nil {
		return ""
	}
	return b.Version
}

func (b *BackwardsCompatGeneratorPublishConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BackwardsCompatGeneratorPublishConfig) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetRegistries sets the Registries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatGeneratorPublishConfig) SetRegistries(registries *GeneratorRegistriesConfig) {
	b.Registries = registries
	b.require(backwardsCompatGeneratorPublishConfigFieldRegistries)
}

// SetRegistriesV2 sets the RegistriesV2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatGeneratorPublishConfig) SetRegistriesV2(registriesV2 *BackwardsCompatibleRegistriesConfigV2) {
	b.RegistriesV2 = registriesV2
	b.require(backwardsCompatGeneratorPublishConfigFieldRegistriesV2)
}

// SetPublishTarget sets the PublishTarget field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatGeneratorPublishConfig) SetPublishTarget(publishTarget *BackwardsCompatiblePublishTarget) {
	b.PublishTarget = publishTarget
	b.require(backwardsCompatGeneratorPublishConfigFieldPublishTarget)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatGeneratorPublishConfig) SetVersion(version string) {
	b.Version = version
	b.require(backwardsCompatGeneratorPublishConfigFieldVersion)
}

func (b *BackwardsCompatGeneratorPublishConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BackwardsCompatGeneratorPublishConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackwardsCompatGeneratorPublishConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackwardsCompatGeneratorPublishConfig) MarshalJSON() ([]byte, error) {
	type embed BackwardsCompatGeneratorPublishConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BackwardsCompatGeneratorPublishConfig) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	backwardsCompatibleGeneratorConfigFieldDryRun        = big.NewInt(1 << 0)
	backwardsCompatibleGeneratorConfigFieldIrFilepath    = big.NewInt(1 << 1)
	backwardsCompatibleGeneratorConfigFieldOutput        = big.NewInt(1 << 2)
	backwardsCompatibleGeneratorConfigFieldPublish       = big.NewInt(1 << 3)
	backwardsCompatibleGeneratorConfigFieldWorkspaceName = big.NewInt(1 << 4)
	backwardsCompatibleGeneratorConfigFieldOrganization  = big.NewInt(1 << 5)
	backwardsCompatibleGeneratorConfigFieldCustomConfig  = big.NewInt(1 << 6)
	backwardsCompatibleGeneratorConfigFieldEnvironment   = big.NewInt(1 << 7)
)

type BackwardsCompatibleGeneratorConfig struct {
	DryRun     bool                                      `json:"dryRun" url:"dryRun"`
	IrFilepath string                                    `json:"irFilepath" url:"irFilepath"`
	Output     *BackwardsCompatibleGeneratorOutputConfig `json:"output" url:"output"`
	// Deprecated. Use output.mode instead.
	Publish       *BackwardsCompatGeneratorPublishConfig `json:"publish,omitempty" url:"publish,omitempty"`
	WorkspaceName string                                 `json:"workspaceName" url:"workspaceName"`
	Organization  string                                 `json:"organization" url:"organization"`
	CustomConfig  interface{}                            `json:"customConfig" url:"customConfig"`
	Environment   *GeneratorEnvironment                  `json:"environment" url:"environment"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BackwardsCompatibleGeneratorConfig) GetDryRun() bool {
	if b == nil {
		return false
	}
	return b.DryRun
}

func (b *BackwardsCompatibleGeneratorConfig) GetIrFilepath() string {
	if b == nil {
		return ""
	}
	return b.IrFilepath
}

func (b *BackwardsCompatibleGeneratorConfig) GetOutput() *BackwardsCompatibleGeneratorOutputConfig {
	if b == nil {
		return nil
	}
	return b.Output
}

func (b *BackwardsCompatibleGeneratorConfig) GetPublish() *BackwardsCompatGeneratorPublishConfig {
	if b == nil {
		return nil
	}
	return b.Publish
}

func (b *BackwardsCompatibleGeneratorConfig) GetWorkspaceName() string {
	if b == nil {
		return ""
	}
	return b.WorkspaceName
}

func (b *BackwardsCompatibleGeneratorConfig) GetOrganization() string {
	if b == nil {
		return ""
	}
	return b.Organization
}

func (b *BackwardsCompatibleGeneratorConfig) GetCustomConfig() interface{} {
	if b == nil {
		return nil
	}
	return b.CustomConfig
}

func (b *BackwardsCompatibleGeneratorConfig) GetEnvironment() *GeneratorEnvironment {
	if b == nil {
		return nil
	}
	return b.Environment
}

func (b *BackwardsCompatibleGeneratorConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BackwardsCompatibleGeneratorConfig) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetDryRun sets the DryRun field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetDryRun(dryRun bool) {
	b.DryRun = dryRun
	b.require(backwardsCompatibleGeneratorConfigFieldDryRun)
}

// SetIrFilepath sets the IrFilepath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetIrFilepath(irFilepath string) {
	b.IrFilepath = irFilepath
	b.require(backwardsCompatibleGeneratorConfigFieldIrFilepath)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetOutput(output *BackwardsCompatibleGeneratorOutputConfig) {
	b.Output = output
	b.require(backwardsCompatibleGeneratorConfigFieldOutput)
}

// SetPublish sets the Publish field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetPublish(publish *BackwardsCompatGeneratorPublishConfig) {
	b.Publish = publish
	b.require(backwardsCompatibleGeneratorConfigFieldPublish)
}

// SetWorkspaceName sets the WorkspaceName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetWorkspaceName(workspaceName string) {
	b.WorkspaceName = workspaceName
	b.require(backwardsCompatibleGeneratorConfigFieldWorkspaceName)
}

// SetOrganization sets the Organization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetOrganization(organization string) {
	b.Organization = organization
	b.require(backwardsCompatibleGeneratorConfigFieldOrganization)
}

// SetCustomConfig sets the CustomConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetCustomConfig(customConfig interface{}) {
	b.CustomConfig = customConfig
	b.require(backwardsCompatibleGeneratorConfigFieldCustomConfig)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorConfig) SetEnvironment(environment *GeneratorEnvironment) {
	b.Environment = environment
	b.require(backwardsCompatibleGeneratorConfigFieldEnvironment)
}

func (b *BackwardsCompatibleGeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BackwardsCompatibleGeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackwardsCompatibleGeneratorConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackwardsCompatibleGeneratorConfig) MarshalJSON() ([]byte, error) {
	type embed BackwardsCompatibleGeneratorConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BackwardsCompatibleGeneratorConfig) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	backwardsCompatibleGeneratorOutputConfigFieldPath = big.NewInt(1 << 0)
	backwardsCompatibleGeneratorOutputConfigFieldMode = big.NewInt(1 << 1)
)

type BackwardsCompatibleGeneratorOutputConfig struct {
	Path string                         `json:"path" url:"path"`
	Mode *BackwardsCompatibleOutputMode `json:"mode" url:"mode"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BackwardsCompatibleGeneratorOutputConfig) GetPath() string {
	if b == nil {
		return ""
	}
	return b.Path
}

func (b *BackwardsCompatibleGeneratorOutputConfig) GetMode() *BackwardsCompatibleOutputMode {
	if b == nil {
		return nil
	}
	return b.Mode
}

func (b *BackwardsCompatibleGeneratorOutputConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BackwardsCompatibleGeneratorOutputConfig) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorOutputConfig) SetPath(path string) {
	b.Path = path
	b.require(backwardsCompatibleGeneratorOutputConfigFieldPath)
}

// SetMode sets the Mode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleGeneratorOutputConfig) SetMode(mode *BackwardsCompatibleOutputMode) {
	b.Mode = mode
	b.require(backwardsCompatibleGeneratorOutputConfigFieldMode)
}

func (b *BackwardsCompatibleGeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BackwardsCompatibleGeneratorOutputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackwardsCompatibleGeneratorOutputConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackwardsCompatibleGeneratorOutputConfig) MarshalJSON() ([]byte, error) {
	type embed BackwardsCompatibleGeneratorOutputConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BackwardsCompatibleGeneratorOutputConfig) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BackwardsCompatibleOutputMode struct {
	Type          string
	Publish       *BackwardsCompatGeneratorPublishConfig
	DownloadFiles interface{}
	Github        *GithubOutputMode
}

func (b *BackwardsCompatibleOutputMode) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BackwardsCompatibleOutputMode) GetPublish() *BackwardsCompatGeneratorPublishConfig {
	if b == nil {
		return nil
	}
	return b.Publish
}

func (b *BackwardsCompatibleOutputMode) GetDownloadFiles() interface{} {
	if b == nil {
		return nil
	}
	return b.DownloadFiles
}

func (b *BackwardsCompatibleOutputMode) GetGithub() *GithubOutputMode {
	if b == nil {
		return nil
	}
	return b.Github
}

func (b *BackwardsCompatibleOutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "publish":
		value := new(BackwardsCompatGeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Publish = value
	case "downloadFiles":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Github = value
	}
	return nil
}

func (b BackwardsCompatibleOutputMode) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Publish != nil {
		return internal.MarshalJSONWithExtraProperty(b.Publish, "type", "publish")
	}
	if b.DownloadFiles != nil {
		var marshaler = struct {
			Type          string      `json:"type"`
			DownloadFiles interface{} `json:"downloadFiles,omitempty"`
		}{
			Type:          "downloadFiles",
			DownloadFiles: b.DownloadFiles,
		}
		return json.Marshal(marshaler)
	}
	if b.Github != nil {
		return internal.MarshalJSONWithExtraProperty(b.Github, "type", "github")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BackwardsCompatibleOutputModeVisitor interface {
	VisitPublish(*BackwardsCompatGeneratorPublishConfig) error
	VisitDownloadFiles(interface{}) error
	VisitGithub(*GithubOutputMode) error
}

func (b *BackwardsCompatibleOutputMode) Accept(visitor BackwardsCompatibleOutputModeVisitor) error {
	if b.Publish != nil {
		return visitor.VisitPublish(b.Publish)
	}
	if b.DownloadFiles != nil {
		return visitor.VisitDownloadFiles(b.DownloadFiles)
	}
	if b.Github != nil {
		return visitor.VisitGithub(b.Github)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BackwardsCompatibleOutputMode) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Publish != nil {
		fields = append(fields, "publish")
	}
	if b.DownloadFiles != nil {
		fields = append(fields, "downloadFiles")
	}
	if b.Github != nil {
		fields = append(fields, "github")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

type BackwardsCompatiblePublishTarget struct {
	Type string
	Npm  *NpmRegistryConfigV2
}

func (b *BackwardsCompatiblePublishTarget) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BackwardsCompatiblePublishTarget) GetNpm() *NpmRegistryConfigV2 {
	if b == nil {
		return nil
	}
	return b.Npm
}

func (b *BackwardsCompatiblePublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npm = value
	}
	return nil
}

func (b BackwardsCompatiblePublishTarget) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Npm != nil {
		return internal.MarshalJSONWithExtraProperty(b.Npm, "type", "npm")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BackwardsCompatiblePublishTargetVisitor interface {
	VisitNpm(*NpmRegistryConfigV2) error
}

func (b *BackwardsCompatiblePublishTarget) Accept(visitor BackwardsCompatiblePublishTargetVisitor) error {
	if b.Npm != nil {
		return visitor.VisitNpm(b.Npm)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BackwardsCompatiblePublishTarget) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Npm != nil {
		fields = append(fields, "npm")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

// For the ts generators that are not backwards compatible.
var (
	backwardsCompatibleRegistriesConfigV2FieldMaven = big.NewInt(1 << 0)
	backwardsCompatibleRegistriesConfigV2FieldNpm   = big.NewInt(1 << 1)
	backwardsCompatibleRegistriesConfigV2FieldPypi  = big.NewInt(1 << 2)
)

type BackwardsCompatibleRegistriesConfigV2 struct {
	Maven *MavenRegistryConfigV2 `json:"maven" url:"maven"`
	Npm   *NpmRegistryConfigV2   `json:"npm" url:"npm"`
	Pypi  *PypiRegistryConfig    `json:"pypi" url:"pypi"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BackwardsCompatibleRegistriesConfigV2) GetMaven() *MavenRegistryConfigV2 {
	if b == nil {
		return nil
	}
	return b.Maven
}

func (b *BackwardsCompatibleRegistriesConfigV2) GetNpm() *NpmRegistryConfigV2 {
	if b == nil {
		return nil
	}
	return b.Npm
}

func (b *BackwardsCompatibleRegistriesConfigV2) GetPypi() *PypiRegistryConfig {
	if b == nil {
		return nil
	}
	return b.Pypi
}

func (b *BackwardsCompatibleRegistriesConfigV2) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BackwardsCompatibleRegistriesConfigV2) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetMaven sets the Maven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleRegistriesConfigV2) SetMaven(maven *MavenRegistryConfigV2) {
	b.Maven = maven
	b.require(backwardsCompatibleRegistriesConfigV2FieldMaven)
}

// SetNpm sets the Npm field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleRegistriesConfigV2) SetNpm(npm *NpmRegistryConfigV2) {
	b.Npm = npm
	b.require(backwardsCompatibleRegistriesConfigV2FieldNpm)
}

// SetPypi sets the Pypi field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BackwardsCompatibleRegistriesConfigV2) SetPypi(pypi *PypiRegistryConfig) {
	b.Pypi = pypi
	b.require(backwardsCompatibleRegistriesConfigV2FieldPypi)
}

func (b *BackwardsCompatibleRegistriesConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler BackwardsCompatibleRegistriesConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackwardsCompatibleRegistriesConfigV2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackwardsCompatibleRegistriesConfigV2) MarshalJSON() ([]byte, error) {
	type embed BackwardsCompatibleRegistriesConfigV2
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BackwardsCompatibleRegistriesConfigV2) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}
