// This file was auto-generated by Fern from our API Definition.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
)

// For the TS generators that use strict parsing.
type BackwardsCompatGeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries,omitempty"`
	// Deprecated, use publishTargets instead.
	RegistriesV2 *BackwardsCompatibleRegistriesConfigV2 `json:"registriesV2,omitempty"`
	// Must always be TS for TypeScript
	PublishTarget *BackwardsCompatiblePublishTarget `json:"publishTarget,omitempty"`
	Version       string                            `json:"version"`
}

type BackwardsCompatibleGeneratorConfig struct {
	DryRun     bool                                      `json:"dryRun"`
	IrFilepath string                                    `json:"irFilepath"`
	Output     *BackwardsCompatibleGeneratorOutputConfig `json:"output,omitempty"`
	// Deprecated. Use output.mode instead.
	Publish       *BackwardsCompatGeneratorPublishConfig `json:"publish,omitempty"`
	WorkspaceName string                                 `json:"workspaceName"`
	Organization  string                                 `json:"organization"`
	CustomConfig  any                                    `json:"customConfig,omitempty"`
	Environment   *GeneratorEnvironment                  `json:"environment,omitempty"`
}

type BackwardsCompatibleGeneratorOutputConfig struct {
	Path string                         `json:"path"`
	Mode *BackwardsCompatibleOutputMode `json:"mode,omitempty"`
}

type BackwardsCompatibleOutputMode struct {
	Type          string
	Publish       *BackwardsCompatGeneratorPublishConfig
	DownloadFiles any
	Github        *GithubOutputMode
}

func NewBackwardsCompatibleOutputModeFromPublish(value *BackwardsCompatGeneratorPublishConfig) *BackwardsCompatibleOutputMode {
	return &BackwardsCompatibleOutputMode{Type: "publish", Publish: value}
}

func NewBackwardsCompatibleOutputModeFromDownloadFiles(value any) *BackwardsCompatibleOutputMode {
	return &BackwardsCompatibleOutputMode{Type: "downloadFiles", DownloadFiles: value}
}

func NewBackwardsCompatibleOutputModeFromGithub(value *GithubOutputMode) *BackwardsCompatibleOutputMode {
	return &BackwardsCompatibleOutputMode{Type: "github", Github: value}
}

func (b *BackwardsCompatibleOutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "publish":
		value := new(BackwardsCompatGeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Publish = value
	case "downloadFiles":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Github = value
	}
	return nil
}

func (b BackwardsCompatibleOutputMode) MarshalJSON() ([]byte, error) {
	switch b.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Type, b)
	case "publish":
		var marshaler = struct {
			Type string `json:"type"`
			*BackwardsCompatGeneratorPublishConfig
		}{
			Type:                                  b.Type,
			BackwardsCompatGeneratorPublishConfig: b.Publish,
		}
		return json.Marshal(marshaler)
	case "downloadFiles":
		var marshaler = struct {
			Type          string `json:"type"`
			DownloadFiles any    `json:"downloadFiles,omitempty"`
		}{
			Type:          b.Type,
			DownloadFiles: b.DownloadFiles,
		}
		return json.Marshal(marshaler)
	case "github":
		var marshaler = struct {
			Type string `json:"type"`
			*GithubOutputMode
		}{
			Type:             b.Type,
			GithubOutputMode: b.Github,
		}
		return json.Marshal(marshaler)
	}
}

type BackwardsCompatibleOutputModeVisitor interface {
	VisitPublish(*BackwardsCompatGeneratorPublishConfig) error
	VisitDownloadFiles(any) error
	VisitGithub(*GithubOutputMode) error
}

func (b *BackwardsCompatibleOutputMode) Accept(visitor BackwardsCompatibleOutputModeVisitor) error {
	switch b.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Type, b)
	case "publish":
		return visitor.VisitPublish(b.Publish)
	case "downloadFiles":
		return visitor.VisitDownloadFiles(b.DownloadFiles)
	case "github":
		return visitor.VisitGithub(b.Github)
	}
}

type BackwardsCompatiblePublishTarget struct {
	Type string
	Npm  *NpmRegistryConfigV2
}

func NewBackwardsCompatiblePublishTargetFromNpm(value *NpmRegistryConfigV2) *BackwardsCompatiblePublishTarget {
	return &BackwardsCompatiblePublishTarget{Type: "npm", Npm: value}
}

func (b *BackwardsCompatiblePublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Npm = value
	}
	return nil
}

func (b BackwardsCompatiblePublishTarget) MarshalJSON() ([]byte, error) {
	switch b.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.Type, b)
	case "npm":
		var marshaler = struct {
			Type string `json:"type"`
			*NpmRegistryConfigV2
		}{
			Type:                b.Type,
			NpmRegistryConfigV2: b.Npm,
		}
		return json.Marshal(marshaler)
	}
}

type BackwardsCompatiblePublishTargetVisitor interface {
	VisitNpm(*NpmRegistryConfigV2) error
}

func (b *BackwardsCompatiblePublishTarget) Accept(visitor BackwardsCompatiblePublishTargetVisitor) error {
	switch b.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", b.Type, b)
	case "npm":
		return visitor.VisitNpm(b.Npm)
	}
}

// For the ts generators that are not backwards compatible.
type BackwardsCompatibleRegistriesConfigV2 struct {
	Maven *MavenRegistryConfigV2 `json:"maven,omitempty"`
	Npm   *NpmRegistryConfigV2   `json:"npm,omitempty"`
	Pypi  *PypiRegistryConfig    `json:"pypi,omitempty"`
}

type BasicLicense struct {
	Id LicenseId `json:"id,omitempty"`
}

type CratesGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl"`
	PackageName                   string              `json:"packageName"`
	TokenEnvironmentVariable      EnvironmentVariable `json:"tokenEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type CratesRegistryConfig struct {
	RegistryUrl string `json:"registryUrl"`
	Token       string `json:"token"`
	PackageName string `json:"packageName"`
}

type CustomLicense struct {
	Filename string `json:"filename"`
}

type EnvironmentVariable = string

type GeneratorConfig struct {
	DryRun                 bool                   `json:"dryRun"`
	IrFilepath             string                 `json:"irFilepath"`
	OriginalReadmeFilepath *string                `json:"originalReadmeFilepath,omitempty"`
	License                *LicenseConfig         `json:"license,omitempty"`
	Output                 *GeneratorOutputConfig `json:"output,omitempty"`
	// Deprecated. Use output.mode instead.
	Publish                  *GeneratorPublishConfig `json:"publish,omitempty"`
	WorkspaceName            string                  `json:"workspaceName"`
	Organization             string                  `json:"organization"`
	CustomConfig             any                     `json:"customConfig,omitempty"`
	Environment              *GeneratorEnvironment   `json:"environment,omitempty"`
	Whitelabel               bool                    `json:"whitelabel"`
	WriteUnitTests           bool                    `json:"writeUnitTests"`
	GeneratePaginatedClients *bool                   `json:"generatePaginatedClients,omitempty"`
	GenerateOauthClients     bool                    `json:"generateOauthClients"`
}

type GeneratorEnvironment struct {
	Type   string
	Local  any
	Remote *RemoteGeneratorEnvironment
}

func NewGeneratorEnvironmentFromLocal(value any) *GeneratorEnvironment {
	return &GeneratorEnvironment{Type: "local", Local: value}
}

func NewGeneratorEnvironmentFromRemote(value *RemoteGeneratorEnvironment) *GeneratorEnvironment {
	return &GeneratorEnvironment{Type: "remote", Remote: value}
}

func (g *GeneratorEnvironment) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "local":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	case "remote":
		value := new(RemoteGeneratorEnvironment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Remote = value
	}
	return nil
}

func (g GeneratorEnvironment) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "local":
		var marshaler = struct {
			Type  string `json:"_type"`
			Local any    `json:"local,omitempty"`
		}{
			Type:  g.Type,
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	case "remote":
		var marshaler = struct {
			Type string `json:"_type"`
			*RemoteGeneratorEnvironment
		}{
			Type:                       g.Type,
			RemoteGeneratorEnvironment: g.Remote,
		}
		return json.Marshal(marshaler)
	}
}

type GeneratorEnvironmentVisitor interface {
	VisitLocal(any) error
	VisitRemote(*RemoteGeneratorEnvironment) error
}

func (g *GeneratorEnvironment) Accept(visitor GeneratorEnvironmentVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "local":
		return visitor.VisitLocal(g.Local)
	case "remote":
		return visitor.VisitRemote(g.Remote)
	}
}

type GeneratorOutputConfig struct {
	Path                    string              `json:"path"`
	SnippetFilepath         *string             `json:"snippetFilepath,omitempty"`
	SnippetTemplateFilepath *string             `json:"snippetTemplateFilepath,omitempty"`
	PublishingMetadata      *PublishingMetadata `json:"publishingMetadata,omitempty"`
	Mode                    *OutputMode         `json:"mode,omitempty"`
}

type GeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries,omitempty"`
	// Deprecated, use publishTargets instead.
	RegistriesV2  *GeneratorRegistriesConfigV2 `json:"registriesV2,omitempty"`
	PublishTarget *GeneratorPublishTarget      `json:"publishTarget,omitempty"`
	Version       string                       `json:"version"`
}

type GeneratorPublishTarget struct {
	Type     string
	Maven    *MavenRegistryConfigV2
	Npm      *NpmRegistryConfigV2
	Pypi     *PypiRegistryConfig
	Postman  *PostmanConfig
	Rubygems *RubyGemsRegistryConfig
	Nuget    *NugetRegistryConfig
	Crates   *CratesRegistryConfig
}

func NewGeneratorPublishTargetFromMaven(value *MavenRegistryConfigV2) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "maven", Maven: value}
}

func NewGeneratorPublishTargetFromNpm(value *NpmRegistryConfigV2) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "npm", Npm: value}
}

func NewGeneratorPublishTargetFromPypi(value *PypiRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "pypi", Pypi: value}
}

func NewGeneratorPublishTargetFromPostman(value *PostmanConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "postman", Postman: value}
}

func NewGeneratorPublishTargetFromRubygems(value *RubyGemsRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "rubygems", Rubygems: value}
}

func NewGeneratorPublishTargetFromNuget(value *NugetRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "nuget", Nuget: value}
}

func NewGeneratorPublishTargetFromCrates(value *CratesRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "crates", Crates: value}
}

func (g *GeneratorPublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "maven":
		value := new(MavenRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "pypi":
		value := new(PypiRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "postman":
		value := new(PostmanConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "rubygems":
		value := new(RubyGemsRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	case "crates":
		value := new(CratesRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Crates = value
	}
	return nil
}

func (g GeneratorPublishTarget) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "maven":
		var marshaler = struct {
			Type string `json:"type"`
			*MavenRegistryConfigV2
		}{
			Type:                  g.Type,
			MavenRegistryConfigV2: g.Maven,
		}
		return json.Marshal(marshaler)
	case "npm":
		var marshaler = struct {
			Type string `json:"type"`
			*NpmRegistryConfigV2
		}{
			Type:                g.Type,
			NpmRegistryConfigV2: g.Npm,
		}
		return json.Marshal(marshaler)
	case "pypi":
		var marshaler = struct {
			Type string `json:"type"`
			*PypiRegistryConfig
		}{
			Type:               g.Type,
			PypiRegistryConfig: g.Pypi,
		}
		return json.Marshal(marshaler)
	case "postman":
		var marshaler = struct {
			Type string `json:"type"`
			*PostmanConfig
		}{
			Type:          g.Type,
			PostmanConfig: g.Postman,
		}
		return json.Marshal(marshaler)
	case "rubygems":
		var marshaler = struct {
			Type string `json:"type"`
			*RubyGemsRegistryConfig
		}{
			Type:                   g.Type,
			RubyGemsRegistryConfig: g.Rubygems,
		}
		return json.Marshal(marshaler)
	case "nuget":
		var marshaler = struct {
			Type string `json:"type"`
			*NugetRegistryConfig
		}{
			Type:                g.Type,
			NugetRegistryConfig: g.Nuget,
		}
		return json.Marshal(marshaler)
	case "crates":
		var marshaler = struct {
			Type string `json:"type"`
			*CratesRegistryConfig
		}{
			Type:                 g.Type,
			CratesRegistryConfig: g.Crates,
		}
		return json.Marshal(marshaler)
	}
}

type GeneratorPublishTargetVisitor interface {
	VisitMaven(*MavenRegistryConfigV2) error
	VisitNpm(*NpmRegistryConfigV2) error
	VisitPypi(*PypiRegistryConfig) error
	VisitPostman(*PostmanConfig) error
	VisitRubygems(*RubyGemsRegistryConfig) error
	VisitNuget(*NugetRegistryConfig) error
	VisitCrates(*CratesRegistryConfig) error
}

func (g *GeneratorPublishTarget) Accept(visitor GeneratorPublishTargetVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "maven":
		return visitor.VisitMaven(g.Maven)
	case "npm":
		return visitor.VisitNpm(g.Npm)
	case "pypi":
		return visitor.VisitPypi(g.Pypi)
	case "postman":
		return visitor.VisitPostman(g.Postman)
	case "rubygems":
		return visitor.VisitRubygems(g.Rubygems)
	case "nuget":
		return visitor.VisitNuget(g.Nuget)
	case "crates":
		return visitor.VisitCrates(g.Crates)
	}
}

type GeneratorRegistriesConfig struct {
	Maven *MavenRegistryConfig `json:"maven,omitempty"`
	Npm   *NpmRegistryConfig   `json:"npm,omitempty"`
}

type GeneratorRegistriesConfigV2 struct {
	Maven    *MavenRegistryConfigV2  `json:"maven,omitempty"`
	Npm      *NpmRegistryConfigV2    `json:"npm,omitempty"`
	Pypi     *PypiRegistryConfig     `json:"pypi,omitempty"`
	Rubygems *RubyGemsRegistryConfig `json:"rubygems,omitempty"`
	Nuget    *NugetRegistryConfig    `json:"nuget,omitempty"`
	Crates   *CratesRegistryConfig   `json:"crates,omitempty"`
}

type GithubOutputMode struct {
	Version string `json:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl"`
	// The token scoped to installing the repository. If not specified, the generator
	// should NOT attempt to clone the repository.
	InstallationToken *string            `json:"installationToken,omitempty"`
	PublishInfo       *GithubPublishInfo `json:"publishInfo,omitempty"`
}

type GithubPublishInfo struct {
	Type     string
	Npm      *NpmGithubPublishInfo
	Maven    *MavenGithubPublishInfo
	Postman  *PostmanGithubPublishInfo
	Pypi     *PypiGithubPublishInfo
	Rubygems *RubyGemsGithubPublishInfo
	Nuget    *NugetGithubPublishInfo
	Crates   *CratesGithubPublishInfo
}

func NewGithubPublishInfoFromNpm(value *NpmGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "npm", Npm: value}
}

func NewGithubPublishInfoFromMaven(value *MavenGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "maven", Maven: value}
}

func NewGithubPublishInfoFromPostman(value *PostmanGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "postman", Postman: value}
}

func NewGithubPublishInfoFromPypi(value *PypiGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "pypi", Pypi: value}
}

func NewGithubPublishInfoFromRubygems(value *RubyGemsGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "rubygems", Rubygems: value}
}

func NewGithubPublishInfoFromNuget(value *NugetGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "nuget", Nuget: value}
}

func NewGithubPublishInfoFromCrates(value *CratesGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "crates", Crates: value}
}

func (g *GithubPublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "maven":
		value := new(MavenGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "postman":
		value := new(PostmanGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "pypi":
		value := new(PypiGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "rubygems":
		value := new(RubyGemsGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	case "crates":
		value := new(CratesGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Crates = value
	}
	return nil
}

func (g GithubPublishInfo) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "npm":
		var marshaler = struct {
			Type string `json:"type"`
			*NpmGithubPublishInfo
		}{
			Type:                 g.Type,
			NpmGithubPublishInfo: g.Npm,
		}
		return json.Marshal(marshaler)
	case "maven":
		var marshaler = struct {
			Type string `json:"type"`
			*MavenGithubPublishInfo
		}{
			Type:                   g.Type,
			MavenGithubPublishInfo: g.Maven,
		}
		return json.Marshal(marshaler)
	case "postman":
		var marshaler = struct {
			Type string `json:"type"`
			*PostmanGithubPublishInfo
		}{
			Type:                     g.Type,
			PostmanGithubPublishInfo: g.Postman,
		}
		return json.Marshal(marshaler)
	case "pypi":
		var marshaler = struct {
			Type string `json:"type"`
			*PypiGithubPublishInfo
		}{
			Type:                  g.Type,
			PypiGithubPublishInfo: g.Pypi,
		}
		return json.Marshal(marshaler)
	case "rubygems":
		var marshaler = struct {
			Type string `json:"type"`
			*RubyGemsGithubPublishInfo
		}{
			Type:                      g.Type,
			RubyGemsGithubPublishInfo: g.Rubygems,
		}
		return json.Marshal(marshaler)
	case "nuget":
		var marshaler = struct {
			Type string `json:"type"`
			*NugetGithubPublishInfo
		}{
			Type:                   g.Type,
			NugetGithubPublishInfo: g.Nuget,
		}
		return json.Marshal(marshaler)
	case "crates":
		var marshaler = struct {
			Type string `json:"type"`
			*CratesGithubPublishInfo
		}{
			Type:                    g.Type,
			CratesGithubPublishInfo: g.Crates,
		}
		return json.Marshal(marshaler)
	}
}

type GithubPublishInfoVisitor interface {
	VisitNpm(*NpmGithubPublishInfo) error
	VisitMaven(*MavenGithubPublishInfo) error
	VisitPostman(*PostmanGithubPublishInfo) error
	VisitPypi(*PypiGithubPublishInfo) error
	VisitRubygems(*RubyGemsGithubPublishInfo) error
	VisitNuget(*NugetGithubPublishInfo) error
	VisitCrates(*CratesGithubPublishInfo) error
}

func (g *GithubPublishInfo) Accept(visitor GithubPublishInfoVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "npm":
		return visitor.VisitNpm(g.Npm)
	case "maven":
		return visitor.VisitMaven(g.Maven)
	case "postman":
		return visitor.VisitPostman(g.Postman)
	case "pypi":
		return visitor.VisitPypi(g.Pypi)
	case "rubygems":
		return visitor.VisitRubygems(g.Rubygems)
	case "nuget":
		return visitor.VisitNuget(g.Nuget)
	case "crates":
		return visitor.VisitCrates(g.Crates)
	}
}

type LicenseConfig struct {
	Type   string
	Basic  *BasicLicense
	Custom *CustomLicense
}

func NewLicenseConfigFromBasic(value *BasicLicense) *LicenseConfig {
	return &LicenseConfig{Type: "basic", Basic: value}
}

func NewLicenseConfigFromCustom(value *CustomLicense) *LicenseConfig {
	return &LicenseConfig{Type: "custom", Custom: value}
}

func (l *LicenseConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Basic = value
	case "custom":
		value := new(CustomLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Custom = value
	}
	return nil
}

func (l LicenseConfig) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "basic":
		var marshaler = struct {
			Type string `json:"type"`
			*BasicLicense
		}{
			Type:         l.Type,
			BasicLicense: l.Basic,
		}
		return json.Marshal(marshaler)
	case "custom":
		var marshaler = struct {
			Type string `json:"type"`
			*CustomLicense
		}{
			Type:          l.Type,
			CustomLicense: l.Custom,
		}
		return json.Marshal(marshaler)
	}
}

type LicenseConfigVisitor interface {
	VisitBasic(*BasicLicense) error
	VisitCustom(*CustomLicense) error
}

func (l *LicenseConfig) Accept(visitor LicenseConfigVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "basic":
		return visitor.VisitBasic(l.Basic)
	case "custom":
		return visitor.VisitCustom(l.Custom)
	}
}

type LicenseId uint

const (
	LicenseIdMit LicenseId = iota + 1
	LicenseIdApache2
)

func (l LicenseId) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LicenseIdMit:
		return "MIT"
	case LicenseIdApache2:
		return "Apache-2.0"
	}
}

func (l LicenseId) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LicenseId) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "MIT":
		value := LicenseIdMit
		*l = value
	case "Apache-2.0":
		value := LicenseIdApache2
		*l = value
	}
	return nil
}

type MavenCentralSignature struct {
	KeyId     string `json:"keyId"`
	Password  string `json:"password"`
	SecretKey string `json:"secretKey"`
}

type MavenCentralSignatureGithubInfo struct {
	KeyIdEnvironmentVariable     EnvironmentVariable `json:"keyIdEnvironmentVariable"`
	PasswordEnvironmentVariable  EnvironmentVariable `json:"passwordEnvironmentVariable"`
	SecretKeyEnvironmentVariable EnvironmentVariable `json:"secretKeyEnvironmentVariable"`
}

type MavenGithubPublishInfo struct {
	RegistryUrl                   string                           `json:"registryUrl"`
	Coordinate                    string                           `json:"coordinate"`
	UsernameEnvironmentVariable   EnvironmentVariable              `json:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable              `json:"passwordEnvironmentVariable"`
	Signature                     *MavenCentralSignatureGithubInfo `json:"signature,omitempty"`
	ShouldGeneratePublishWorkflow *bool                            `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type MavenRegistryConfig struct {
	RegistryUrl string                 `json:"registryUrl"`
	Username    string                 `json:"username"`
	Password    string                 `json:"password"`
	Group       string                 `json:"group"`
	Signature   *MavenCentralSignature `json:"signature,omitempty"`
}

type MavenRegistryConfigV2 struct {
	RegistryUrl string                 `json:"registryUrl"`
	Username    string                 `json:"username"`
	Password    string                 `json:"password"`
	Coordinate  string                 `json:"coordinate"`
	Signature   *MavenCentralSignature `json:"signature,omitempty"`
}

type NpmGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl"`
	PackageName                   string              `json:"packageName"`
	TokenEnvironmentVariable      EnvironmentVariable `json:"tokenEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type NpmRegistryConfig struct {
	RegistryUrl string `json:"registryUrl"`
	Token       string `json:"token"`
	Scope       string `json:"scope"`
}

type NpmRegistryConfigV2 struct {
	RegistryUrl string `json:"registryUrl"`
	Token       string `json:"token"`
	PackageName string `json:"packageName"`
}

type NugetGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl"`
	PackageName                   string              `json:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type NugetRegistryConfig struct {
	RegistryUrl string `json:"registryUrl"`
	ApiKey      string `json:"apiKey"`
	PackageName string `json:"packageName"`
}

type OutputMetadata struct {
	Description *string                 `json:"description,omitempty"`
	Authors     []*OutputMetadataAuthor `json:"authors,omitempty"`
}

type OutputMetadataAuthor struct {
	Name  string `json:"name"`
	Email string `json:"email"`
}

type OutputMode struct {
	Type          string
	Publish       *GeneratorPublishConfig
	DownloadFiles any
	Github        *GithubOutputMode
}

func NewOutputModeFromPublish(value *GeneratorPublishConfig) *OutputMode {
	return &OutputMode{Type: "publish", Publish: value}
}

func NewOutputModeFromDownloadFiles(value any) *OutputMode {
	return &OutputMode{Type: "downloadFiles", DownloadFiles: value}
}

func NewOutputModeFromGithub(value *GithubOutputMode) *OutputMode {
	return &OutputMode{Type: "github", Github: value}
}

func (o *OutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "publish":
		value := new(GeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Publish = value
	case "downloadFiles":
		value := make(map[string]any)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Github = value
	}
	return nil
}

func (o OutputMode) MarshalJSON() ([]byte, error) {
	switch o.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "publish":
		var marshaler = struct {
			Type string `json:"type"`
			*GeneratorPublishConfig
		}{
			Type:                   o.Type,
			GeneratorPublishConfig: o.Publish,
		}
		return json.Marshal(marshaler)
	case "downloadFiles":
		var marshaler = struct {
			Type          string `json:"type"`
			DownloadFiles any    `json:"downloadFiles,omitempty"`
		}{
			Type:          o.Type,
			DownloadFiles: o.DownloadFiles,
		}
		return json.Marshal(marshaler)
	case "github":
		var marshaler = struct {
			Type string `json:"type"`
			*GithubOutputMode
		}{
			Type:             o.Type,
			GithubOutputMode: o.Github,
		}
		return json.Marshal(marshaler)
	}
}

type OutputModeVisitor interface {
	VisitPublish(*GeneratorPublishConfig) error
	VisitDownloadFiles(any) error
	VisitGithub(*GithubOutputMode) error
}

func (o *OutputMode) Accept(visitor OutputModeVisitor) error {
	switch o.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "publish":
		return visitor.VisitPublish(o.Publish)
	case "downloadFiles":
		return visitor.VisitDownloadFiles(o.DownloadFiles)
	case "github":
		return visitor.VisitGithub(o.Github)
	}
}

type PostmanConfig struct {
	ApiKey      string `json:"apiKey"`
	WorkspaceId string `json:"workspaceId"`
}

type PostmanGithubPublishInfo struct {
	ApiKeyEnvironmentVariable      EnvironmentVariable `json:"apiKeyEnvironmentVariable"`
	WorkspaceIdEnvironmentVariable EnvironmentVariable `json:"workspaceIdEnvironmentVariable"`
}

// This should effectively be deprecated in favor of a more specific configuration per-output mode (pypi, maven, etc.).
type PublishingMetadata struct {
	PackageDescription *string `json:"package_description,omitempty"`
	PublisherEmail     *string `json:"publisher_email,omitempty"`
	ReferenceUrl       *string `json:"reference_url,omitempty"`
	PublisherName      *string `json:"publisher_name,omitempty"`
}

type PypiGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl"`
	PackageName                   string              `json:"packageName"`
	UsernameEnvironmentVariable   EnvironmentVariable `json:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable `json:"passwordEnvironmentVariable"`
	PypiMetadata                  *PypiMetadata       `json:"pypiMetadata,omitempty"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type PypiMetadata struct {
	Description       *string                 `json:"description,omitempty"`
	Authors           []*OutputMetadataAuthor `json:"authors,omitempty"`
	Keywords          []string                `json:"keywords,omitempty"`
	DocumentationLink *string                 `json:"documentationLink,omitempty"`
	HomepageLink      *string                 `json:"homepageLink,omitempty"`
}

type PypiRegistryConfig struct {
	RegistryUrl  string        `json:"registryUrl"`
	Username     string        `json:"username"`
	Password     string        `json:"password"`
	PackageName  string        `json:"packageName"`
	PypiMetadata *PypiMetadata `json:"pypiMetadata,omitempty"`
}

type RemoteGeneratorEnvironment struct {
	CoordinatorUrl   string `json:"coordinatorUrl"`
	CoordinatorUrlV2 string `json:"coordinatorUrlV2"`
	Id               TaskId `json:"id"`
}

type RubyGemsGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl"`
	PackageName                   string              `json:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty"`
}

type RubyGemsRegistryConfig struct {
	RegistryUrl string `json:"registryUrl"`
	ApiKey      string `json:"apiKey"`
	PackageName string `json:"packageName"`
}

type CratesCoordinate struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type ErrorExitStatusUpdate struct {
	Message string `json:"message"`
}

type ExitStatusUpdate struct {
	Type       string
	Successful *SuccessfulStatusUpdate
	Error      *ErrorExitStatusUpdate
}

func NewExitStatusUpdateFromSuccessful(value *SuccessfulStatusUpdate) *ExitStatusUpdate {
	return &ExitStatusUpdate{Type: "successful", Successful: value}
}

func NewExitStatusUpdateFromError(value *ErrorExitStatusUpdate) *ExitStatusUpdate {
	return &ExitStatusUpdate{Type: "error", Error: value}
}

func (e *ExitStatusUpdate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "successful":
		value := new(SuccessfulStatusUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Successful = value
	case "error":
		value := new(ErrorExitStatusUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Error = value
	}
	return nil
}

func (e ExitStatusUpdate) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "successful":
		var marshaler = struct {
			Type string `json:"_type"`
			*SuccessfulStatusUpdate
		}{
			Type:                   e.Type,
			SuccessfulStatusUpdate: e.Successful,
		}
		return json.Marshal(marshaler)
	case "error":
		var marshaler = struct {
			Type string `json:"_type"`
			*ErrorExitStatusUpdate
		}{
			Type:                  e.Type,
			ErrorExitStatusUpdate: e.Error,
		}
		return json.Marshal(marshaler)
	}
}

type ExitStatusUpdateVisitor interface {
	VisitSuccessful(*SuccessfulStatusUpdate) error
	VisitError(*ErrorExitStatusUpdate) error
}

func (e *ExitStatusUpdate) Accept(visitor ExitStatusUpdateVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "successful":
		return visitor.VisitSuccessful(e.Successful)
	case "error":
		return visitor.VisitError(e.Error)
	}
}

type InitUpdate struct {
	PackagesToPublish []*PackageCoordinate `json:"packagesToPublish,omitempty"`
}

type InitUpdateV2 struct {
	PublishingToRegistry *RegistryType `json:"publishingToRegistry,omitempty"`
}

type LogLevel uint

const (
	LogLevelDebug LogLevel = iota + 1
	LogLevelInfo
	LogLevelWarn
	LogLevelError
)

func (l LogLevel) String() string {
	switch l {
	default:
		return strconv.Itoa(int(l))
	case LogLevelDebug:
		return "DEBUG"
	case LogLevelInfo:
		return "INFO"
	case LogLevelWarn:
		return "WARN"
	case LogLevelError:
		return "ERROR"
	}
}

func (l LogLevel) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", l.String())), nil
}

func (l *LogLevel) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "DEBUG":
		value := LogLevelDebug
		*l = value
	case "INFO":
		value := LogLevelInfo
		*l = value
	case "WARN":
		value := LogLevelWarn
		*l = value
	case "ERROR":
		value := LogLevelError
		*l = value
	}
	return nil
}

type LogUpdate struct {
	Level   LogLevel `json:"level,omitempty"`
	Message string   `json:"message"`
}

type MavenCoordinate struct {
	Group    string `json:"group"`
	Artifact string `json:"artifact"`
	Version  string `json:"version"`
}

type NpmCoordinate struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type PackageCoordinate struct {
	Type   string
	Npm    *NpmCoordinate
	Maven  *MavenCoordinate
	Crates *CratesCoordinate
}

func NewPackageCoordinateFromNpm(value *NpmCoordinate) *PackageCoordinate {
	return &PackageCoordinate{Type: "npm", Npm: value}
}

func NewPackageCoordinateFromMaven(value *MavenCoordinate) *PackageCoordinate {
	return &PackageCoordinate{Type: "maven", Maven: value}
}

func NewPackageCoordinateFromCrates(value *CratesCoordinate) *PackageCoordinate {
	return &PackageCoordinate{Type: "crates", Crates: value}
}

func (p *PackageCoordinate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Npm = value
	case "maven":
		value := new(MavenCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Maven = value
	case "crates":
		value := new(CratesCoordinate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Crates = value
	}
	return nil
}

func (p PackageCoordinate) MarshalJSON() ([]byte, error) {
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "npm":
		var marshaler = struct {
			Type string `json:"_type"`
			*NpmCoordinate
		}{
			Type:          p.Type,
			NpmCoordinate: p.Npm,
		}
		return json.Marshal(marshaler)
	case "maven":
		var marshaler = struct {
			Type string `json:"_type"`
			*MavenCoordinate
		}{
			Type:            p.Type,
			MavenCoordinate: p.Maven,
		}
		return json.Marshal(marshaler)
	case "crates":
		var marshaler = struct {
			Type string `json:"_type"`
			*CratesCoordinate
		}{
			Type:             p.Type,
			CratesCoordinate: p.Crates,
		}
		return json.Marshal(marshaler)
	}
}

type PackageCoordinateVisitor interface {
	VisitNpm(*NpmCoordinate) error
	VisitMaven(*MavenCoordinate) error
	VisitCrates(*CratesCoordinate) error
}

func (p *PackageCoordinate) Accept(visitor PackageCoordinateVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "npm":
		return visitor.VisitNpm(p.Npm)
	case "maven":
		return visitor.VisitMaven(p.Maven)
	case "crates":
		return visitor.VisitCrates(p.Crates)
	}
}

type RegistryType uint

const (
	RegistryTypeNpm RegistryType = iota + 1
	RegistryTypeMaven
	RegistryTypePypi
	RegistryTypeRubygems
	RegistryTypeNuget
	RegistryTypeCrates
)

func (r RegistryType) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RegistryTypeNpm:
		return "NPM"
	case RegistryTypeMaven:
		return "MAVEN"
	case RegistryTypePypi:
		return "PYPI"
	case RegistryTypeRubygems:
		return "RUBYGEMS"
	case RegistryTypeNuget:
		return "NUGET"
	case RegistryTypeCrates:
		return "CRATES"
	}
}

func (r RegistryType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RegistryType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "NPM":
		value := RegistryTypeNpm
		*r = value
	case "MAVEN":
		value := RegistryTypeMaven
		*r = value
	case "PYPI":
		value := RegistryTypePypi
		*r = value
	case "RUBYGEMS":
		value := RegistryTypeRubygems
		*r = value
	case "NUGET":
		value := RegistryTypeNuget
		*r = value
	case "CRATES":
		value := RegistryTypeCrates
		*r = value
	}
	return nil
}

type SuccessfulStatusUpdate struct {
	ZipFilename *string `json:"zipFilename,omitempty"`
}

type TaskId = string

type BadgeType uint

const (
	BadgeTypeNpm BadgeType = iota + 1
	BadgeTypeMaven
	BadgeTypePypi
	BadgeTypeGo
	BadgeTypeRubygems
	BadgeTypeNuget
	BadgeTypeCrates
)

func (b BadgeType) String() string {
	switch b {
	default:
		return strconv.Itoa(int(b))
	case BadgeTypeNpm:
		return "NPM"
	case BadgeTypeMaven:
		return "MAVEN"
	case BadgeTypePypi:
		return "PYPI"
	case BadgeTypeGo:
		return "GO"
	case BadgeTypeRubygems:
		return "RUBYGEMS"
	case BadgeTypeNuget:
		return "NUGET"
	case BadgeTypeCrates:
		return "CRATES"
	}
}

func (b BadgeType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", b.String())), nil
}

func (b *BadgeType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "NPM":
		value := BadgeTypeNpm
		*b = value
	case "MAVEN":
		value := BadgeTypeMaven
		*b = value
	case "PYPI":
		value := BadgeTypePypi
		*b = value
	case "GO":
		value := BadgeTypeGo
		*b = value
	case "RUBYGEMS":
		value := BadgeTypeRubygems
		*b = value
	case "NUGET":
		value := BadgeTypeNuget
		*b = value
	case "CRATES":
		value := BadgeTypeCrates
		*b = value
	}
	return nil
}

type CsharpEndpointSnippet struct {
	// A full endpoint snippet, including the client instantiation, e.g.
	//
	// using Acme;
	//
	// var acme = new AcmeClient("<YOUR_API_KEY>");
	// await acme.Admin.Update(new UpdateAdminRequest
	// {
	// Id = "submission-12o3uds",
	// SubmissionState = RunningSubmissionState.QueueingSubmission,
	// });
	Client string `json:"client"`
}

type Endpoint struct {
	// The id of the example used to create the snippet.
	ExampleIdentifier *string             `json:"example_identifier,omitempty"`
	Id                *EndpointIdentifier `json:"id,omitempty"`
	Snippet           *EndpointSnippet    `json:"snippet,omitempty"`
}

type EndpointIdentifier struct {
	Path   EndpointPath   `json:"path"`
	Method EndpointMethod `json:"method,omitempty"`
	// The ID for the endpoint as declared within the IR, this is a unique name for the endpoint, whereas path and
	// method are not (specifically for the fern definition, consider chat and chat stream). This is optional to
	// remain backcompat with old snippets of yore.
	IdentifierOverride *string `json:"identifier_override,omitempty"`
}

type EndpointMethod uint

const (
	EndpointMethodPut EndpointMethod = iota + 1
	EndpointMethodPost
	EndpointMethodGet
	EndpointMethodPatch
	EndpointMethodDelete
	EndpointMethodHead
)

func (e EndpointMethod) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EndpointMethodPut:
		return "PUT"
	case EndpointMethodPost:
		return "POST"
	case EndpointMethodGet:
		return "GET"
	case EndpointMethodPatch:
		return "PATCH"
	case EndpointMethodDelete:
		return "DELETE"
	case EndpointMethodHead:
		return "HEAD"
	}
}

func (e EndpointMethod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EndpointMethod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "PUT":
		value := EndpointMethodPut
		*e = value
	case "POST":
		value := EndpointMethodPost
		*e = value
	case "GET":
		value := EndpointMethodGet
		*e = value
	case "PATCH":
		value := EndpointMethodPatch
		*e = value
	case "DELETE":
		value := EndpointMethodDelete
		*e = value
	case "HEAD":
		value := EndpointMethodHead
		*e = value
	}
	return nil
}

// The relative path for an endpont (e.g. `/users/{userId}`)
type EndpointPath = string

// Defines a variety of different formats for an individual endpoint's snippet
type EndpointSnippet struct {
	Type       string
	Typescript *TypescriptEndpointSnippet
	Python     *PythonEndpointSnippet
	Java       *JavaEndpointSnippet
	Go         *GoEndpointSnippet
	Ruby       *RubyEndpointSnippet
	Csharp     *CsharpEndpointSnippet
	Rust       *RustEndpointSnippet
}

func NewEndpointSnippetFromTypescript(value *TypescriptEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "typescript", Typescript: value}
}

func NewEndpointSnippetFromPython(value *PythonEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "python", Python: value}
}

func NewEndpointSnippetFromJava(value *JavaEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "java", Java: value}
}

func NewEndpointSnippetFromGo(value *GoEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "go", Go: value}
}

func NewEndpointSnippetFromRuby(value *RubyEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "ruby", Ruby: value}
}

func NewEndpointSnippetFromCsharp(value *CsharpEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "csharp", Csharp: value}
}

func NewEndpointSnippetFromRust(value *RustEndpointSnippet) *EndpointSnippet {
	return &EndpointSnippet{Type: "rust", Rust: value}
}

func (e *EndpointSnippet) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "typescript":
		value := new(TypescriptEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Typescript = value
	case "python":
		value := new(PythonEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Python = value
	case "java":
		value := new(JavaEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Java = value
	case "go":
		value := new(GoEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Go = value
	case "ruby":
		value := new(RubyEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Ruby = value
	case "csharp":
		value := new(CsharpEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Csharp = value
	case "rust":
		value := new(RustEndpointSnippet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rust = value
	}
	return nil
}

func (e EndpointSnippet) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "typescript":
		var marshaler = struct {
			Type string `json:"type"`
			*TypescriptEndpointSnippet
		}{
			Type:                      e.Type,
			TypescriptEndpointSnippet: e.Typescript,
		}
		return json.Marshal(marshaler)
	case "python":
		var marshaler = struct {
			Type string `json:"type"`
			*PythonEndpointSnippet
		}{
			Type:                  e.Type,
			PythonEndpointSnippet: e.Python,
		}
		return json.Marshal(marshaler)
	case "java":
		var marshaler = struct {
			Type string `json:"type"`
			*JavaEndpointSnippet
		}{
			Type:                e.Type,
			JavaEndpointSnippet: e.Java,
		}
		return json.Marshal(marshaler)
	case "go":
		var marshaler = struct {
			Type string `json:"type"`
			*GoEndpointSnippet
		}{
			Type:              e.Type,
			GoEndpointSnippet: e.Go,
		}
		return json.Marshal(marshaler)
	case "ruby":
		var marshaler = struct {
			Type string `json:"type"`
			*RubyEndpointSnippet
		}{
			Type:                e.Type,
			RubyEndpointSnippet: e.Ruby,
		}
		return json.Marshal(marshaler)
	case "csharp":
		var marshaler = struct {
			Type string `json:"type"`
			*CsharpEndpointSnippet
		}{
			Type:                  e.Type,
			CsharpEndpointSnippet: e.Csharp,
		}
		return json.Marshal(marshaler)
	case "rust":
		var marshaler = struct {
			Type string `json:"type"`
			*RustEndpointSnippet
		}{
			Type:                e.Type,
			RustEndpointSnippet: e.Rust,
		}
		return json.Marshal(marshaler)
	}
}

type EndpointSnippetVisitor interface {
	VisitTypescript(*TypescriptEndpointSnippet) error
	VisitPython(*PythonEndpointSnippet) error
	VisitJava(*JavaEndpointSnippet) error
	VisitGo(*GoEndpointSnippet) error
	VisitRuby(*RubyEndpointSnippet) error
	VisitCsharp(*CsharpEndpointSnippet) error
	VisitRust(*RustEndpointSnippet) error
}

func (e *EndpointSnippet) Accept(visitor EndpointSnippetVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "typescript":
		return visitor.VisitTypescript(e.Typescript)
	case "python":
		return visitor.VisitPython(e.Python)
	case "java":
		return visitor.VisitJava(e.Java)
	case "go":
		return visitor.VisitGo(e.Go)
	case "ruby":
		return visitor.VisitRuby(e.Ruby)
	case "csharp":
		return visitor.VisitCsharp(e.Csharp)
	case "rust":
		return visitor.VisitRust(e.Rust)
	}
}

type GoEndpointSnippet struct {
	// A full endpoint snippet, including the client instantiation, e.g.
	//
	// import (
	// "context"
	// "fmt"
	//
	// acme "github.com/acme/acme-go"
	// acmeclient "github.com/acme/acme-go/client"
	// )
	//
	// client := acmeclient.NewClient(
	// acmeclient.WithApiKey("..."),
	// )
	// client.Admin.Update(
	// context.TODO(),
	// "submission-12o3uds",
	// &acme.AdminUpdateRequest{
	// SubmissionState: acme.RunningSubmissionStateQueuingSubmission,
	// },
	// )
	Client string `json:"client"`
}

type JavaEndpointSnippet struct {
	// A full endpoint snippet, including the sync client instantiation, e.g.
	//
	// import com.acme.AcmeApiClient;
	// import com.acme.resources.types.RunningSubmissionState;
	//
	// AcmeClient acmeClient = AcmeClient.builder()
	// .apiKey("...")
	// .build();
	//
	// acmeClient.admin().create(
	// "submission-12o3uds",
	// AdminUpdateRequest.builder()
	// .submissionState(RunningSubmissionState.QUEUEING_SUBMISSION)
	// .build());
	SyncClient string `json:"sync_client"`
	// A full endpoint snippet, including the async client instantiation, e.g.
	//
	// import com.acme.AcmeApiClient;
	// import com.acme.resources.types.RunningSubmissionState;
	//
	// AcmeClient acmeClient = AcmeClient.builder()
	// .apiKey("API_KEY")
	// .build();
	//
	// acmeClient.admin().create(
	// "submission-12o3uds",
	// AdminUpdateRequest.builder()
	// .submissionState(RunningSubmissionState.QUEUEING_SUBMISSION)
	// .build());
	AsyncClient string `json:"async_client"`
}

type PythonEndpointSnippet struct {
	// A full endpoint snippet, including the sync client instantiation, e.g.
	//
	// from acme import RunningSubmissionState
	// from acme.client import Acme
	//
	// client = Acme(api_key="...")
	// client.admin.update(
	// submission_id="submission-12o3uds",
	// request=RunningSubmissionState.QUEUEING_SUBMISSION,
	// )
	SyncClient string `json:"sync_client"`
	// A full endpoint snippet, including the async client instantiation, e.g.
	//
	// from acme import RunningSubmissionState
	// from acme.client import AsyncAcme
	//
	// client = AsyncAcme(api_key="...")
	// await client.admin.update(
	// submission_id="submission-12o3uds",
	// request=RunningSubmissionState.QUEUEING_SUBMISSION,
	// )
	AsyncClient string `json:"async_client"`
}

type RubyEndpointSnippet struct {
	// A full endpoint snippet, including the client instantiation, e.g.
	//
	// require "acme"
	//
	// acme = Acme::Client.new(
	// apiKey: 'YOUR_API_KEY'
	// )
	// acme.admin.update(
	// submission_id: "submission-12o3uds",
	// request: Acme::RunningSubmissionState::QUEUEING_SUBMISSION
	// )
	Client string `json:"client"`
}

type RustEndpointSnippet struct {
	// A full endpoint snippet, including the client instantiation, e.g.
	//
	// use acme::{AcmeClient, RunningSubmissionState};
	//
	// let client = AcmeClient::new("YOUR_API_KEY");
	// client.admin().update(
	// "submission-12o3uds",
	// RunningSubmissionState::QueueingSubmission,
	// ).await?;
	Client string `json:"client"`
}

// The code snippets defined in the API
type Snippets struct {
	// The type snippets defined by by the API
	Types map[TypeId]string `json:"types,omitempty"`
	// The endpoint snippets defined by the API
	Endpoints []*Endpoint `json:"endpoints,omitempty"`
}

type TypeId = string

type TypescriptEndpointSnippet struct {
	// A full endpoint snippet, including the client instantiation, e.g.
	//
	// import { AcmeClient, Acme } from '@acme/acme-node-client';
	//
	// const acme = new AcmeClient({
	// apiKey: 'YOUR_API_KEY',
	// });
	// await acme.admin.update({
	// submission_id: "submission-12o3uds",
	// request: Acme.RunningSubmissionState.QUEUEING_SUBMISSION,
	// });
	Client string `json:"client"`
}
